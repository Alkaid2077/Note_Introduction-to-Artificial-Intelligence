# 人工智能导论_复旦大学_智慧慕课学习空间

## 绪章

### 课程导引

#### 1. **人工智能：科学的思考方式**

- 像人一样思考 -> 理性地思考
- 像人一样行动 -> 理性地行动
- ->理性的决策

  - 理性的决策：可以最优地达成预先定义目标的决策
  - “理性”的评价仅仅基于决策（并不在意背后的思考过程）
  - 目标：基于执行结果的效用进行刻画
  - 理性；最大化期望的效用值 

#### 2. **课程目标**

- 智能体：一个可以完成*感知*和*动作*的实体。
- 理性的智能体：选择最大化期望效用的动作。
- 核心要素：反馈，环境和动作空间。
- 基于三大核心要素进行动作选择。
- 课程内容：
  - 学习针对一系列问题类型的通用人工智能技术
  - 学习如何使用现有技术进行新问题的建模和求解

#### 3. 人工智能技术学习路径

- 基础_真实世界的问题：路径寻址，吃豆人，五子棋，……
- 抽象_形式化任务（模型）：搜索问题，马尔可夫决策过程，贝叶斯问题，……
- 计算_任务的解决（算法）：深度优先，策略优先，维特比算法

## 一、无信息搜索

### (一) 搜索问题定义

#### 1. 搜索问题四要素

- **状态/状态空间**
  - 状态描述一个具体的场景
  - 状态空间包含了所有的可能状态
- **后继函数（动作、损耗）**
  - 状态通过动作选择而产生连接的关系
  - 动作空间表示某一个状态下可以采取的动作集合
- **开始状态**
  - 问题开始的状态
- **结束状态**
  - 问题结束的条件

#### 2. 吃豆人游戏

>背景：小黄人吃豆子，小豆子+大豆子，有敌人，小黄人碰到敌人gg，吃到大豆子可以变大吃敌人

- 状态空间：游戏过程中的某个画面的截图，每一个小格子都是一个状态的可能，所有的格子的状态组成了状态空间
- 后继函数
  - 动作空间：上，下，左，右，动作可以连接两个状态
  - 损耗：每个动作都有损耗，单步损耗为1
  - 如小黄人从（1，1）移动到（1，2），向右移动一格，（1，2）里有豆子，小黄人就吃到了豆子，这个向右一格的动作连接了两个状态
- 开始状态：如小黄人从（1，1）的状态开始，其他格子里有豆子
- 目标测试：如移动到某一个特定的位置/吃完所有豆子

#### 3. 八数码问题

>在 3x3 的格子中有 1~8 八个数字，你可以移动一个数码到它旁边的空格子中，从开始状态达到目标状态
>![alt text](image-1.png)

- 状态空间：8 个数码的位置，每一个都可以用二维数组表示（x, y）
- 后继函数：移动空白格子：上，下，左，右

#### 4. 八皇后问题

> 在 8x8 的棋盘上，陆续摆上 8 个皇后，并保证皇后之间两两不互相攻击（皇后可以攻击同一行、同一列、同一正对角线/反对角线的棋子），在图示例子中，我们还需要摆放 3 个皇后 
> ![alt text](image-2.png)

- 状态空间：0 ~ 8 个皇后摆在棋盘上；使用一个 8x8 的矩阵，布尔值
- 后继函数：增加一个皇后到棋盘上
- 开始状态：空白的棋盘
- 目标测试：8 个皇后在棋盘上，两两不攻击

#### 5. 罗马尼亚交通图

> ![alt text](image-3.png)

- 状态空间：图中的节点集（城市是节点）
- 后继函数：动作-可以去往有边相连的城市；损耗-城市间的距离
- 开始状态：Arad （城市）
- 目标检测：当前所处的城市是否是 Bucharest？

### （二）搜索空间

#### 1. 状态空间

- **全局状态空间**：建模没环境中包含的每一个可描述变量（细节），如包括小黄人的位置，豆子分布情况，大豆子小豆子，敌人等等
- **搜索状态空间**：仅需要建模解决特定搜索问题需要的变量，不需要所有的变量
  - 问题：路径寻址
    - 状态：（x, y）小黄人的位置
    - 动作：上下左右
    - 后继：根据动作更新位置
    - 目标：当前状态是否目标位置
  - 问题：吃完所有豆子
    - 状态：{（x,y），豆子分布情况}
    - 动作：上下左右
    - 后继：根据动作状态
    - 目标：所有豆子都被吃了

#### 2. 状态空间的大小 - 八皇后问题

- 全局状态空间：期盼的格子数目 64，皇后的数目 8
- 全局状态空间大小：$64^8$

#### 3. 状态空间的大小 - 吃豆人

- 全局状态空间：小黄人活动空间 120，豆子个数 30，鬼怪活动空间 12，小黄人朝向 上下左右
- 全局状态空间大小：$120*(2^{30})*(12^2)*4$
- 路径搜索状态空间大小：$120$
- 吃完所有豆子状态空间：$120*(2^{30})$

### （三）搜索问题的表示：状态空间图和搜索树

#### 1. 状态空间图

- 定义：一种针对搜索问题的数学表示形式
  - 节点：抽象的状态
  - 边：后继函数（状态执行动作的结果）
  - 目标检测：一个目标节点的集合（可能只有一个）
- 在状态空间图中，每一个问题中的状态只出现一次
- 状态空间图中的节点与问题中的状态一一对应

#### 2. 搜索树

- 树是有向无环图，有根节点，边的个数是节点个数减一
  - 开始状态是根节点
  - 子节点对应父节点的后继状态
  - 节点对应状态，并且包含了从开始状态到当前状态的路径，
  - **路径表示一个动作序列**

#### 3. 状态空间图到搜索树的转换

![alt text](image-4.png)

- 搜索树中的一个节点对应状态空间图中的一条完整路径
- 状态空间图中的节点可以对应到搜索树中的多个状态节点，也就是说，**搜索树中不同的节点可能表示相同的状态，只是路径不同**

#### 4. 状态空间图 vs. 搜索树

考虑以下 4 状态的状态空间图，它对应的搜索树是怎么样的？
![alt text](image-5.png)

此图中 a,b 一直在循环。在搜索树中包含了非常多的重复结构，因此，对于绝大部分问题来说，我们不能完整画出它对应的搜索树。

### （四）搜索算法的基本设定和评测

#### 1. 搜索问题的求解

- 解决一个搜索问题就是确定从开始状态到一个结束状态的动作序列，也被称为规划

#### 2. 搜索算法的标准设定

- 过程
  - 搜索开始：从搜索树的根节点开始
  - 节点扩展：访问一个未被访问的但已经被发现的节点
  - 节点生成：发现新的节点
  - 目标测试：判断当前接待你对应的状态是否是目标状态
- 实现模块
  - 搜索边缘：已经生成但是未被访问的节点集合
  - 节点扩展：访问一个节点，并枚举它所有邻居节点
  - 节点生成：将新节点加入到搜索边缘

> 注意：**生成 = 发现， 访问 = 扩展**

#### 3. 搜索算法的评价

- 搜索树中的一些符号 ![alt text](image-6.png)
  - b 表示分支因子，树能到达的宽度
  - m 表示最大搜索高度/深度
  - s 目标状态对应的节点（可以为多个）
- 搜索树中的总节点个数：$1+b+b^2+...+b^m = \frac{1-b^{m+1}}{1-b} = O(b^m)$
- 评价搜索算法的四个指标
  - 完备性：如果存在目标节点，是否可以保证搜索到？
  - 最优性：最先找到的目标节点是不是损耗最小的？（如先找到更浅层的目标节点，而不是深的）
  - 时间复杂度：生成的节点个数（如果算法要生成所有的节点，那它的时间复杂度就是 $O(b^m)$
  - 空间复杂度：需要的存储空空间（搜索边缘的大小），即要保存找到的但未访问的节点的空间大小

### （五）树搜索和图搜索



### （六）代价无关搜索算法



### （七）一致代价搜索算法


## 二、有信息搜索





## 三、对抗搜索




## 四、约束满足问题




## 五、强化学习 - 有模型的方法




## 六、强化学习 - 无模型的方法


## 七、强化学习 - 值函数近似的方法





## 八、概率图模型 - 表示




## 八、概率图模型 - 推理



## 八、概率图模型 - 隐马尔可夫模型




## 九、强化学习模块



## 十、搜索算法模块